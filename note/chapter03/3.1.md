- [3.1 符号表](#31-符号表)
  - [3.1.1 API](#311-api)
  - [3.1.4 无序链表中的顺序查找](#314-无序链表中的顺序查找)
  - [3.1.5 有序数组中的二分查找](#315-有序数组中的二分查找)
  - [3.1.6 对二分查找的分析](#316-对二分查找的分析)
  - [3.1.7 预览](#317-预览)
# 3.1 符号表
* 符号表是一种存储键值对的数据结构，指出两种操作：插入(put)，即将一组新的键值对存入表中；查找(get)，即根据给定的键得到相应的值。

## 3.1.1 API
我们所有实现都遵循以下规则：
  1. 每个键只对应着一个值（表中不允许存在重复的键）；
  2. 当用例代码向表中存入的键值对喝表中已有的键（及关联的值）冲突时，新的值会替代旧的值。
 * 键不能为空。
 * 不允许空值。
 * 删除的实现：延时删除、即时删除。
 * 最好使用不可变的数据类型作为键，否则表的一致性是无法保证的。
## 3.1.4 无序链表中的顺序查找
* 使用命中表示一次成功的查找，未命中表示一次失败的查找。
* 算法3.1 [顺序查找(基于无序链表)](/Algorithms/src/chapter03/SequentialSearchST.java)
* **命题A**。在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要～N^2/2次比较。
* **推论**。像一个空表中插入N个不同的键需要～N^2/2次比较。
* 基于链表的实现及顺序查找是非常低效的。

## 3.1.5 有序数组中的二分查找
* 使用的数据结构是一对平行的数组，一个存储键一个存储值。
* 和以前一样，我们可以**动态调整数组**，使得用例无需担心数组大小（请注意，你会发现这种方法**对于大数组实在是太慢了**）。
* 算法3.2 [二分查找(基于有序数组)](/Algorithms/src/chapter03/BinarySearchST.java)
* 递归的rank()方法：
  * 如果表中存在该键，rank()应该返回该键的位置，也就是表中小于它的键的数量；
  * 如果表中不存在该键，rank()还是应该返回表中小于它的键的数量。

## 3.1.6 对二分查找的分析
* **命题B**。在N个键的有序数组中进行二分查找最多需要（lgN + 1）次比较（无论是否成功）。
* **命题B（续）**。向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问～2N次数组，因此像一个空符号表中插入N个元素在最坏情况下需要访问～N^2次数组。
## 3.1.7 预览
* 简单的符号表实现的成本总结
* 为了将二分查找的效率和链表的灵活性结合起来，可以使用二叉查找树。
* 符号表的各种实现的优缺点
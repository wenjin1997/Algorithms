- [2.1 初级排序算法](#21-初级排序算法)
  - [2.1.1 游戏规则](#211-游戏规则)
  - [2.1.2 选择排序](#212-选择排序)
  - [2.1.3 插入排序](#213-插入排序)
  - [2.1.4 排序算法的可视化](#214-排序算法的可视化)
  - [2.1.5 比较两种排序算法](#215-比较两种排序算法)
  - [2.1.6 希尔排序](#216-希尔排序)
# 2.1 初级排序算法
## 2.1.1 游戏规则
* 排序算法模板：[Example.java](/Algorithms/src/chapter02/Example.java)
* 上述代码使得排序方法适用于任意实现了Comparable接口的数据类型。

## 2.1.2 选择排序
* 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素，那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序。
* 对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换。
* 选择排序算法：[Selection.java](/Algorithms/src/chapter02/Selection.java)

## 2.1.3 插入排序
* 插入排序和整理桥牌的方法一样，将每一张牌插入到其他已经有序的牌中的适当位置。
* 对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要～N^2/4次比较和～N^2/4次交换。最坏情况下需要～N^2/2次比较和～N^2/2次交换，最好情况下需要N-1次比较和0次交换。
* 插入排序算法对部分有序数组非常有效，也很适合小规模数组。
* 插入排序算法：[Insertion.java](/Algorithms/src/chapter02/Insertion.java)

## 2.1.4 排序算法的可视化
* 插入排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素。

## 2.1.5 比较两种排序算法
* 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。
* 比较两种排序的算法：[SortCompare.java](/Algorithms/src/chapter02/SortCompare.java)

## 2.1.6 希尔排序
* 希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。
* 希尔排序的思想是使数组中任意间隔h的元素都是有序的。
* 希尔排序算法：[Shell.java](/Algorithms/src/chapter02/Shell.java)
* 希尔排序可以用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。
* 上诉算法的运行时间达不到平方级别。在最坏情况下[Shell.java](/Algorithms/src/chapter02/Shell.java)的比较次数和N^{3/2}成正比。
* 如果需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或是运行于嵌入式系统中的代码），可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。
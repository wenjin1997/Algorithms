- [1.3 背包、队列和栈](#13-背包队列和栈)
  - [1.3.1 API](#131-api)
    - [1.3.1 泛型](#131-泛型)
    - [1.3.2 自动装箱](#132-自动装箱)
    - [1.3.3 可迭代的集合类型](#133-可迭代的集合类型)
    - [1.3.1.4 背包](#1314-背包)
    - [1.3.1.5 队列](#1315-队列)
    - [1.3.1.6 下压栈](#1316-下压栈)
    - [1.3.1.7 算术表达式求值](#1317-算术表达式求值)
  - [1.3.2 集合类数据类型的实现](#132-集合类数据类型的实现)
    - [1.3.2.1 定容栈](#1321-定容栈)
    - [1.3.2.2 泛型](#1322-泛型)
    - [1.3.2.3 调整数组大小](#1323-调整数组大小)
    - [1.3.2.4 对象游离](#1324-对象游离)
    - [1.3.2.5 迭代](#1325-迭代)
  - [1.3.3 链表](#133-链表)
    - [算法实现](#算法实现)
  - [1.3.4 综述](#134-综述)
# 1.3 背包、队列和栈
* 背包、队列和栈的不同之处在于删除或者访问对象的顺序不同。

## 1.3.1 API
### 1.3.1 泛型
* 泛型也叫做参数化类型。
* 如果没有泛型，我们必须为需要收集的每种数据类型定义(并实现)不同的API。有了泛型，我们只需要一份API(和一次实现)就能够处理所有类型的数据，甚至是在未来定义的数据类型。

### 1.3.2 自动装箱
* 类型参数必须被实例化为引用类型。
* 自动将一个原始数据类型转换为一个封装类型被称为**自动装箱**，自动将一个封装类型转换为一个原始数据类型被称为**自动拆箱**。

### 1.3.3 可迭代的集合类型
* 用例的要求只是用某种方式处理集合中的每个元素，或者叫做**迭代访问**集合中的所有元素。
* 如果集合是可迭代的，可以使用`foreach`语句
    ```java
    for (Transaction t : collection)
    {   StdOut.println(t);}
    ```

### 1.3.1.4 背包
* 背包是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。
* 背包的典型用例:计算标准输入中所有double值的平均值和样本标准差 [Stats.java](/Algorithms/src/chapter01/bag/Stats.java)

### 1.3.1.5 队列
* **先进先出队列**是一种基于先进先出(FIFO)策略的集合类型。
* 当用例使用`foreach`语句迭代访问队列照片那个的元素时，元素的处理顺序就是它们被添加到队列中的顺序。
* Queue的用例
```java
public static int[] readInts(String name){
    In in = new In(name);
    Queue<Integer> q = new Queue<>();
    while (!in.isEmpty())
        q.enqueue(in.readInt());
    
    int N = q.size();
    int[] a = new int[N];
    for (int i = 0; i < N; i++) {
        a[i] = q.dequeue();
    }
    return a;
}
```    

### 1.3.1.6 下压栈
* 下压栈是一种基于后进先出(LIFO)策略的集合类型。
* 当用例使用`foreach`语句迭代遍历栈中的元素时，元素的处理顺序和它们被压入的顺序正好相反。

### 1.3.1.7 算术表达式求值
* 用两个栈(一个用于保存运算符，一个用于保存操作数)完成。
* Dijkstra的双栈算术表达式求值算法：[Evaluate.java](/Algorithms/src/chapter01/stack/Evaluate.java)

## 1.3.2 集合类数据类型的实现
### 1.3.2.1 定容栈
* 先看一种表示容量固定的字符串栈的抽象数据类型。
* 它只能处理String值，它要求用例指定一个容量且不支持迭代。
* 用例：[FixedCapacityStackOfStrings.java](/Algorithms/src/chapter01/stack/FixedCapacityStackOfStrings.java)

### 1.3.2.2 泛型
* 将`FixedCapacityStack<Item>`理解为某种元素的栈。
* 一种表示泛型定容栈的抽象数据类型：[FixedCapacityStack.java](/Algorithms/src/chapter01/stack/FixedCapacityStack.java)

### 1.3.2.3 调整数组大小
* 首先实现一个方法将栈移动到另一个大小不同的数组中。
* 在push()方法中，检查数组的大小是否太小。如果没有多余的空间，我们会将数组的长度加倍。
* 在pop()方法，首先删除栈顶的元素，然后如果数组太大我们就将长度减半。

### 1.3.2.4 对象游离
* 保存一个不需要的对象的引用称为游离。
* 在这里，避免对象游离很容易，只需将被弹出的数组元素的值设为null即可。

### 1.3.2.5 迭代
* 一些在任意可迭代的集合数据类型中我们都需要实现的东西：
  * 集合数据类型必须实现一个iterator()方法并返回一个Iterator对象；
  * Iterator类必须包含两个方法：hasNext()（返回一个布尔值）和next()（返回集合中的一个泛型元素）。
* ⭐️算法1.1 下压栈(能够动态调整数组大小的实现)：[ResizingArrayStack.java](/Algorithms/src/chapter01/stack/ResizingArrayStack.java)

## 1.3.3 链表
* **定义** 链表是一种递归的数据结构，它或者为空(null)，或者指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。

### 算法实现
* 算法1.2 下压堆栈（链表实现）[Stack.java](/Algorithms/src/chapter01/stack/Stack.java)
* 算法1.3 先进先出队列 [Queue.java](/Algorithms/src/chapter01/queue/Queue.java)
* 算法1.4 背包 [Bag.java](/Algorithms/src/chapter01/bag/Bag.java)

## 1.3.4 综述
* 两种表示对象集合的方式：数组和链表，常常被称为顺序存储和链式存储。